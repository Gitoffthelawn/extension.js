import * as path from 'path'
import * as fs from 'fs'
import {urlToRequest} from 'loader-utils'
import {validate} from 'schema-utils'
import {type Schema} from 'schema-utils/declarations/validate'
import {type LoaderContext} from '../../../webpack-types'

const schema: Schema = {
  type: 'object',
  properties: {
    test: {
      type: 'string'
    },
    manifestPath: {
      type: 'string'
    },
    mode: {
      type: 'string'
    },
    includeList: {
      type: 'object'
    },
    excludeList: {
      type: 'object'
    }
  }
}

/**
 * Check if the project is using a JavaScript framework
 */
function isUsingJSFramework(projectPath: string): boolean {
  const packageJsonPath = path.join(projectPath, 'package.json')

  if (!fs.existsSync(packageJsonPath)) {
    return false
  }

  const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'))

  const frameworks = [
    'react',
    'vue',
    '@angular/core',
    'svelte',
    'solid-js',
    'preact'
  ]

  const dependencies = packageJson.dependencies || {}
  const devDependencies = packageJson.devDependencies || {}

  for (const framework of frameworks) {
    if (dependencies[framework] || devDependencies[framework]) {
      return true
    }
  }

  return false
}

/**
 * Extract CSS imports from the source file
 */
function extractCSSImports(source: string): string[] {
  const cssImports: string[] = []

  // Match various CSS import patterns
  const cssImportPatterns = [
    /import\s+['"]([^'"]*\.(?:css|scss|sass|less|module\.css))['"]/g,
    /import\s+['"]([^'"]*\.(?:css|scss|sass|less|module\.css))['"]\s*;?/g,
    /import\s+['"]([^'"]*\.(?:css|scss|sass|less|module\.css))['"]\s*from\s+['"][^'"]*['"]/g
  ]

  for (const pattern of cssImportPatterns) {
    let match
    while ((match = pattern.exec(source)) !== null) {
      const cssPath = match[1]
      if (cssPath && !cssImports.includes(cssPath)) {
        cssImports.push(cssPath)
      }
    }
  }

  return cssImports
}

/**
 * Generate the wrapper code that will be injected
 */
function generateWrapperCode(
  source: string,
  isReact: boolean,
  resourcePath: string
): string {
  const fileName = path.basename(resourcePath, path.extname(resourcePath))

  // Extract CSS imports from the source
  const cssImports = extractCSSImports(source)
  console.log('üîç Detected CSS imports:', cssImports)

  const wrapperCode = `
// Content Script Wrapper - Auto-generated by Extension.js
// This wrapper provides Shadow DOM isolation and CSS injection for content scripts

import contentScript from './${fileName}'

// Content script options interface
export interface ContentScriptOptions {
  rootId?: string
  containerClass?: string
  stylesheets?: string[]
}

// Content script instance interface
export interface ContentScriptInstance {
  mount: (container: HTMLElement) => void
  unmount: () => void
}

// Content script wrapper class
class ContentScriptWrapper {
  private rootElement: HTMLElement | null = null
  private shadowRoot: ShadowRoot | null = null
  private styleElement: HTMLStyleElement | null = null
  private renderFunction: (container: HTMLElement) => (() => void) | void
  private unmountFunction: (() => void) | null = null
  private options: ContentScriptOptions

  constructor(renderFunction: (container: HTMLElement) => (() => void) | void, options: ContentScriptOptions = {}) {
    this.renderFunction = renderFunction
    this.options = {
      rootId: 'extension-root',
      containerClass: 'content_script',
      stylesheets: ${JSON.stringify(cssImports.length > 0 ? cssImports : ['./styles.css'])},
      ...options
    }
  }

  mount(container?: HTMLElement): void {
    if (this.rootElement) {
      this.unmount()
    }

    // Create root element
    this.rootElement = container || document.createElement('div')
    this.rootElement.id = this.options.rootId!
    this.rootElement.className = this.options.containerClass!

    // Create shadow root for style isolation
    this.shadowRoot = this.rootElement.attachShadow({ mode: 'open' })

    // Inject styles
    this.injectStyles()

    // Render content
    const result = this.renderFunction(this.shadowRoot as any)
    if (typeof result === 'function') {
      this.unmountFunction = result
    }

    // Append to document if no container provided
    if (!container) {
      document.body.appendChild(this.rootElement)
    }
  }

  unmount(): void {
    if (this.unmountFunction) {
      this.unmountFunction()
      this.unmountFunction = null
    }

    if (this.rootElement && this.rootElement.parentNode) {
      this.rootElement.parentNode.removeChild(this.rootElement)
    }

    this.rootElement = null
    this.shadowRoot = null
    this.styleElement = null
  }

  /**
   * Inject styles using the working example pattern
   */
  private async injectStyles(): Promise<void> {
    const targetRoot = this.shadowRoot || this.rootElement!

    // Create style element
    this.styleElement = document.createElement('style')
    targetRoot.appendChild(this.styleElement)

    // Fetch CSS using the working example pattern
    try {
      const cssContent = await this.fetchCSS()
      this.styleElement.textContent = cssContent
      console.log('‚úÖ CSS injected successfully')
    } catch (error) {
      console.error('‚ùå Failed to inject CSS:', error)
    }

    // Setup HMR for CSS files
    this.setupCSSHMR()
  }

  /**
   * Fetch CSS using the working example pattern
   */
  private async fetchCSS(): Promise<string> {
    let allCSS = ''
    
    for (const stylesheet of this.options.stylesheets) {
      try {
        const cssUrl = new URL(stylesheet, import.meta.url)
        const response = await fetch(cssUrl)
        const text = await response.text()
        if (response.ok) {
          allCSS += text + '\\n'
        } else {
          console.warn('‚ö†Ô∏è Failed to fetch CSS:', stylesheet)
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Failed to fetch CSS:', stylesheet, error)
      }
    }
    
    return allCSS || '/* No CSS loaded */'
  }

  /**
   * Setup CSS HMR using the working example pattern
   */
  private setupCSSHMR(): void {
    if (!import.meta.webpackHot) return

    // Setup HMR for each CSS file
    for (const stylesheet of this.options.stylesheets) {
      import.meta.webpackHot?.accept(stylesheet, async () => {
        try {
          const cssContent = await this.fetchCSS()
          if (this.styleElement) {
            this.styleElement.textContent = cssContent
            console.log('‚úÖ CSS updated via HMR:', stylesheet)
          }
        } catch (error) {
          console.error('‚ùå Failed to update CSS via HMR:', stylesheet, error)
        }
      })
    }
  }
}

/**
 * Initialize content script with wrapper
 */
function initializeContentScript(
  options: ContentScriptOptions,
  renderFunction: (container: HTMLElement) => (() => void) | void
): ContentScriptInstance {
  const wrapper = new ContentScriptWrapper(renderFunction, options)
  
  return {
    mount: (container?: HTMLElement) => wrapper.mount(container),
    unmount: () => wrapper.unmount()
  }
}

/**
 * Default export for the content script wrapper
 */
export default ContentScriptWrapper

/**
 * Auto-initialize the content script with the wrapper
 * This function automatically sets up the content script using the imported contentScript function
 */
export function autoInitializeContentScript(
  options: ContentScriptOptions = {}
): ContentScriptInstance {
  // Get the render function from the imported contentScript
  const renderFunction = contentScript(options)

  // Initialize with the wrapper using the detected CSS imports
  return initializeContentScript(options, renderFunction)
}

// Simple initialization like the original working code
let unmount: (() => void) | undefined

async function initialize() {
  if (unmount) {
    unmount()
  }
  const instance = autoInitializeContentScript()
  unmount = () => instance.unmount()
}

if (import.meta.webpackHot) {
  import.meta.webpackHot?.accept()
  import.meta.webpackHot?.dispose(() => unmount?.())

  // Accept changes to scripts.tsx specifically
  import.meta.webpackHot?.accept('./${fileName}', () => {
    initialize()
  })
}

if (document.readyState === 'complete') {
  initialize()
} else {
  document.addEventListener('readystatechange', () => {
    if (document.readyState === 'complete') {
      initialize()
    }
  })
}
`

  return wrapperCode
}

export default function (this: LoaderContext, source: string) {
  const options = this.getOptions()
  const manifestPath = options.manifestPath
  const projectPath = path.dirname(manifestPath)
  const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf-8'))

  validate(schema, options, {
    name: 'scripts:add-content-script-wrapper',
    baseDataPath: 'options'
  })

  const url = urlToRequest(this.resourcePath)

  // Check if the source has the 'use shadow-dom' directive
  const hasShadowDomDirective =
    source.includes("'use shadow-dom'") || source.includes('"use shadow-dom"')

  // Only apply wrapper if directive exists and content scripts are using JS frameworks
  if (
    hasShadowDomDirective &&
    manifest.content_scripts &&
    isUsingJSFramework(projectPath)
  ) {
    for (const contentScript of manifest.content_scripts) {
      if (!contentScript.js) continue

      for (const js of contentScript.js) {
        const absoluteUrl = path.resolve(projectPath, js as string)

        if (url.includes(absoluteUrl)) {
          // Check if this is a React/JS framework content script
          const isReact =
            source.includes('react') ||
            source.includes('ReactDOM') ||
            source.includes('createRoot') ||
            source.includes('render(')

          if (isReact) {
            const wrapperCode = generateWrapperCode(
              source,
              isReact,
              this.resourcePath
            )
            return wrapperCode
          }
        }
      }
    }
  }

  return source
}
